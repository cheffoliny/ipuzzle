<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas
	xmlns:mx="http://www.adobe.com/2006/mxml"	
	verticalScrollPolicy="off" horizontalScrollPolicy="off"
	implements="net.telepol.ui.autoComplete.interfaces.iComboItem"
	height="{ textInput.height }"
	initialize="init()">
	
	<mx:Metadata>
		[Event("change")]
	</mx:Metadata>
	
	<mx:Script>
		<![CDATA[
			import mx.core.Application;
			import mx.core.UIComponent;
			import mx.containers.Box;
			import mx.controls.Image;
			import mx.states.SetStyle;
			import net.telepol.telenet.Consts;
			
			private var _prompt:String;
			private var _isPromptSet:Boolean;

			private var _isMouseOver:Boolean;
			
			private function init():void
			{
				addEventListener( FocusEvent.FOCUS_IN, handleFocusIn );
				addEventListener( FocusEvent.FOCUS_OUT, handleFocusOut );
				addEventListener( MouseEvent.MOUSE_OVER, handleMouseOver );
				addEventListener( MouseEvent.MOUSE_OUT, handleMouseOut );
				
				textInput.addEventListener( Event.CHANGE, handleChange );				
				
				showPrompt();
			}
			
			private function showPrompt():void {
				if (_prompt == null) {
					return;
				}
				
				if (!textInput) {
					return;
				}
				
				// check that the component isn't currently focused
				var focus:InteractiveObject = textInput.getFocus();
				
				if (focus && focus.parent == textInput) {
					return;
				}
				
				_isPromptSet = true;
				textInput.text = _prompt;
				
				setStyle( "color", Consts.COLOR_TEXT_DISABLED );
				setStyle( "fontStyle", "italic" );
			}
			
			private function hidePrompt():void
			{
				if (_isPromptSet)
				{
					textInput.text = "";	
				}
				
				_isPromptSet = false;
				
				clearStyle( "color" );
				clearStyle( "fontStyle" );
			}
			
			public function set prompt( value:String ):void
			{
				_prompt = value;
				
				showPrompt();
			}
			
			override public function validateNow():void
			{
				super.validateNow();
				
				textInput.validateNow();
			}
			
			public function get text():String
			{
				if (_isPromptSet)
				{
					return "";
				}
				else
				{
					// When setting the htmlText property there's a delay until the text
					// property is ready. This will force it to update it's text value 
					if (textInput.text == null && textInput.htmlText != null)
					{
						validateNow();
					}
					
					return textInput.text;
				}
			}
			
			public function get htmlText():String
			{
				if (_isPromptSet)
				{
					return "";
				}
				else
				{
					return textInput.htmlText;
				}
			}
			
			public function get selectionBeginIndex():int
			{
				return textInput.selectionBeginIndex;
			}
			
			public function set text( value:String ):void {
				if (value == null) {
					textInput.text = "";
					textInput.setSelection( 0, 0 );
					
					showPrompt();
				}	
				else {
					hidePrompt();
					textInput.text = value;							
				}								
			}
			
			public function set htmlText( value:String ):void {
				if (value == null) {
					textInput.htmlText = "";
					textInput.setSelection( 0, 0 );
					
					showPrompt();
				}	
				else {
					hidePrompt();
					textInput.htmlText = value;																		
				}					
			}
			
			public function setTextSelected( value:Boolean ):void
			{
				var startPos:uint = value ? 0 : text.length;
				
				textInput.setSelection( startPos, text.length );
			}
				
			private function handleFocusIn( event:FocusEvent ):void
			{
				if (_isPromptSet)
				{
					hidePrompt();
				}
			}
			
			private function handleFocusOut( event:FocusEvent ):void
			{
				if (textInput.text.length == 0)
				{
					showPrompt();
				}
			}
			
			private function handleChange( event:Event ):void
			{
				dispatchEvent( event );
				
				// this helps keep the input at a good 
				// horizontal scroll position
				var scrollPos:int 		= textInput.horizontalScrollPosition;
    			var maxScrollPos:int 	= textInput.maxHorizontalScrollPosition;
    			
    			if (scrollPos - maxScrollPos > 50) {
    				textInput.horizontalScrollPosition -= 50;
    			}																	
			}
			
			private function handleMouseOver( event:MouseEvent ):void
			{
				_isMouseOver = true;
				
				if (text.length == 0) {
					return;
				}
			}
			
			private function handleMouseOut( event:MouseEvent ):void {
				_isMouseOver = false;
			}
			
			private function handleClearClick( event:Event ):void {
				text = null;
				hidePrompt();
				setFocus();
				
				dispatchEvent( new Event( Event.CHANGE ) );
			}
			
			override public function setFocus():void {
				textInput.setFocus();
			}	
			
			public function setTextFocus():void {
				textInput.setSelection( 0, 0 );
				setFocus();
			}	
			
			public function isCursorAtBeginning():Boolean
			{
				return selectionBeginIndex == 0;
			}				
			
			public function isCursorAtEnd():Boolean
			{
				return selectionBeginIndex == text.length;
			}

			public function isEditable():Boolean {
				return true;
			}
			
			public function setCursorPosition( value:int ):void
			{
				_setCursorPosition( value );
				callLater( _setCursorPosition, [value] );
			}	
			
			private function _setCursorPosition( value:int ):void
			{
				textInput.selectionBeginIndex = value;
				textInput.selectionEndIndex = value;
			}
			
		]]>
	</mx:Script>
	
	<mx:TextInput id="textInput" width="100%"/>
	
</mx:Canvas>